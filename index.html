<!DOCTYPE html>
<html lang="ru">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300..800;1,300..800&family=Roboto+Slab:wght@100..900&display=swap" rel="stylesheet">
	<link rel="stylesheet" href="css/style.css">
	<title>Тимофей Рукин &mdash; Проектная работа</title>
</head>

<body class="content-grid">

	<section>
		<h1>Создание динамической графики с&nbsp;помощью алгоритмов построения кривых</h1>
		<div class="credits">
			<div class="author">Рукин Тимофей</div>
			<div class="curator">
				<label for="">Куратор</label>
				Лебедев Дмитрий Алексеевич
			</div>
		</div>
	</section>

	<section class="about full content-grid">
		<p>Классические алгоритмы построения кривых, такие как кривые Безье, B-сплайны и другие, сохраняют высокую значимость в современном мире благодаря своей универсальности, эффективности и широкому спектру применения. Они лежат в основе многих технологий, от компьютерной графики и CAD-систем до моделирования сложных поверхностей в инженерии и архитектуре.</p>
	</section>

	<section>
		<h2>Кривые Безье</h2>
		<p>Кривые Безье были разработаны в 1960-х годах независимо двумя инженерами: Пьером Безье и Полем де Кастельжо. Они работали над улучшением аэродинамики автомобильных кузовов, что требовало создания плавных и точных кривых. Пьер Безье опубликовал свои результаты в начале 1960-х годов, поэтому кривые получили его имя. Поль де Кастельжо разработал алгоритм для вычисления, но его работы оставались секретными до конца 1960-х.</p>
		<h3>Построение</h3>
		<div>
			Самым популярным способом построения является метод де Кастельжо:
			<ol>
				<li>Рисуем опорные точки P<sub>0</sub>, P<sub>1</sub>, ... ,P<sub>n</sub> и соединяем их последовательно отрезками: 
					P<sub>0</sub> &RightArrow; P<sub>1</sub>
					P<sub>1</sub> &RightArrow; P<sub>2</sub>
					&RightArrow; ... &RightArrow; P<sub>n</sub>
					Получаем ломаную линию.</li>
				<li>Взять некую переменную t, которая будет меняться от 0 до 1 с определенным интервалом (чем меньше, тем точнее)</li>
				<li>Для каждой t поставить точку на отрезках, пропорциональную t (при t = 0.5 поставить точку на середине) и соединить их. Получится N-1 отрезков</li>
				<li>Повторять, пока не останется одна точка</li>
			</ol>
		</div>

		<section class="result">
			<div class="controls">
				<div>
					Порядок кривой:&nbsp;
					<input type="number" name="bezie_degree" id="" value="2" style="width: 50px;">
				</div>
				<div class="middle">
					<label for="bezie_speed">Скорость:&nbsp;</label>
					<input type="range" name="bezie_speed" id="bezie_speed" min="0" max="100" value="100" step="10">
				</div>
				<!-- <div>
					<input type="checkbox" name="bezie_support" id="bezie_support_btn" checked="checked">
					<label for="bezie_support_btn">Очищать линии</label>
				</div> -->
				<div>
					<input type="button" id="bezie_redraw_btn" value="Перестроить">
				</div>
				<div>
                    <input type="button" id="bezie_reset_btn" value="Заново">
                </div>
				<div>
					<input type="button" id="bezie_demo_btn" value="Демо">
				</div>
			</div>
			<canvas id="bezie" width="1000" height="500">
				Ваш браузер не поддерживает canvas.
			</canvas>
		</section>

	</section>

	<section>
		<h2>B-сплайны</h2>
		<p>B-сплайны были введены американским математиком Исааком Шенбергом в 1946 году. Термин B-сплайн происходит от «basis spline (базисный сплайн)» . B-сплайны обобщают кривую Безье, позволяя управлять формой кривой с помощью контрольных точек, но при этом алгебраическая степень B-сплайна не зависит от их числа.</p>
		<h3>Построение</h3>
		<div><img src="img/bspline.svg" alt="" srcset="" /></div>

		<section class="result">
	    	<div class="controls">
				<div>
					<div>
						<input type="radio" id="bspline_simple" name="bspline_type" value="simple" checked>
						<label for="bspline_simple">Элементарная кубическая</label>
					</div>
					<div>
						<input type="radio" id="bspline_complex" name="bspline_type" value="complex">
						<label for="bspline_complex">Составная</label>
					</div>
				</div>
				<div class="middle">
					<label for="bspline_speed">Скорость:&nbsp;</label>
					<input type="range" name="bspline_speed" id="bspline_speed" min="0" max="100" value="100" step="20">
				</div>
				<div>
					<input type="checkbox" name="bspline_auto" id="bspline_auto_btn">
					<label for="bspline_auto_btn">Достраивать автоматически</label>
				</div>
                <div>
                    <input type="button" id="bspline_reset_btn" value="Заново">
                </div>
            </div>
			<canvas id="bspline" width="1000" height="500">
                Ваш браузер не поддерживает canvas.
            </canvas>
		</section>

	</section>

	<section>
		<h2>Кубические сплайны</h2>
		<p>Кубические сплайны имеют более давнюю историю. Их математическое представление восходит к теории расчета изгиба балок, основы которой заложили Леонард Эйлер и Даниил Бернулли около 1750 года. Кубические сплайны изначально описывали форму упругой линии нагруженной балки. В 1938 году В.Кваде и Л.Коллатц применяли сплайны в своих работах, а в 1946 году году Шенберг впервые использовал термин “сплайн” в математическом контексте.</p>

		<section class="result cube tbd">
			скоро
		</section>

	</section>

	<footer class="full content-grid">
		<h2>Источники</h2>
		<h3>Литература:</h3>
		<ul>
			<li>Е.В.Шикин, А.И.Плис. Кривые и поверхности на экране компьютера. &mdash; М.:«ДИАЛОГ-МИФИ», 1996</li>
		</ul>
		<h3>Ссылки:</h3>
		<ul>
			<li>Сайт, учебник по JavaScript <a href="https://learn.javascript.ru/">https://learn.javascript.ru/</a></li>
			<li>Почти всё про кривые Безье <a href="https://learn.javascript.ru/bezier-curve">https://learn.javascript.ru/bezier-curve</a></li>
			<li>Основные свойства кривой Безье и В-сплайна, также блок теории <a href="https://post.nghiatu.com/ru/tutorial/computer-graphics/computer-graphics-curves/krivye-komp-uternoj-grafiki">https://post.nghiatu.com/ru/tutorial/computer-graphics/computer-graphics-curves/krivye-komp-uternoj-grafiki</a></li>
			<li>Youtube: Bezier Curves Explained <a href="https://www.youtube.com/watch?v=pnYccz1Ha34">https://www.youtube.com/watch?v=pnYccz1Ha34</a></li>
			<li>Youtube: The Beauty of Bézier Curves <a href="https://www.youtube.com/watch?v=aVwxzDHniEw">https://www.youtube.com/watch?v=aVwxzDHniEw</a></li>
			<li>Youtube: Splines in 5 minutes: Part 3 -- B-splines and 2D <a href="https://www.youtube.com/watch?v=JwN43QAlF50">https://www.youtube.com/watch?v=JwN43QAlF50</a></li>
			<li>Youtube: The Continuity of Splines <a href="https://www.youtube.com/watch?v=jvPPXbo87ds">https://www.youtube.com/watch?v=jvPPXbo87ds</a></li>
			<li>Youtube: A new approach to container and wrapper classes <a href="https://www.youtube.com/watch?v=c13gpBrnGEw">https://www.youtube.com/watch?v=c13gpBrnGEw</a></li>
		</ul>
	</footer>

	<div class="demo">
		<canvas id="bezie_demo" width="1000" height="500">
			Ваш браузер не поддерживает canvas.
        </canvas>
	</div>

	<script type="module" defer>

		var letters;
		(function (letters) {
			letters[letters["A"] = 0] = "A";
			letters[letters["B"] = 1] = "B";
			letters[letters["C"] = 2] = "C";
			letters[letters["D"] = 3] = "D";
			letters[letters["E"] = 4] = "E";
			letters[letters["F"] = 5] = "F";
			letters[letters["G"] = 6] = "G";
			letters[letters["H"] = 7] = "H";
			letters[letters["I"] = 8] = "I";
			letters[letters["J"] = 9] = "J";
			letters[letters["K"] = 10] = "K";
			letters[letters["L"] = 11] = "L";
			letters[letters["M"] = 12] = "M";
			letters[letters["N"] = 13] = "N";
			letters[letters["O"] = 14] = "O";
			letters[letters["P"] = 15] = "P";
			letters[letters["Q"] = 16] = "Q";
			letters[letters["R"] = 17] = "R";
			letters[letters["S"] = 18] = "S";
			letters[letters["T"] = 19] = "T";
			letters[letters["U"] = 20] = "U";
			letters[letters["V"] = 21] = "V";
			letters[letters["W"] = 22] = "W";
			letters[letters["X"] = 23] = "X";
			letters[letters["Y"] = 24] = "Y";
			letters[letters["Z"] = 25] = "Z";
		})(letters || (letters = {}));

		var colors;
		(function (colors) {
			colors[colors["121,0,201"] = 0] = "121,0,201";
			colors[colors["255,158,100"] = 1] = "255,158,100";
			colors[colors["83,219,138"] = 2] = "83,219,138";
			colors[colors["221,66,245"] = 3] = "221,66,245";
			colors[colors["143,158,255"] = 4] = "143,158,255";
			colors[colors["255, 241, 0"] = 5] = "255, 241, 0";
			colors[colors["255, 140, 0"] = 6] = "255, 140, 0";
			colors[colors["155, 17, 35"] = 7] = "155, 17, 35";
			colors[colors["104, 33, 122"] = 8] = "104, 33, 122";
			colors[colors["186, 216, 10"] = 9] = "186, 216, 10";
		})(colors || (colors = {}));

		class Bezie {
			constructor(target) {
				this._dots = 3;
				this._data = [];
				this._complex = false;
				this._delta = 0;
				this._start = { x: 0, y: 0 };
				this._storage = [];
				this._userClickCouner = 0;
				this._speed = 100;
				this._clear = () => {
					var _a;
					const rect = this._target.getBoundingClientRect();
					(_a = this._target.getContext('2d')) === null || _a === void 0 ? void 0 : _a.clearRect(0, 0, rect.width, rect.height);
				};
				this._reset = () => {
					this._clear();
					this._delta = 0;
					this._storage = [];
					cancelAnimationFrame(this.animation);
					this._data = [];
					for (var i = 0; i < this._dots; i++) {
						var dot = this._addPoint();
						this._data.push(dot);
					}
					this._start = this._data[0];
					this._reDraw();
				};
				this.init = () => {
					this._reset();
					this._target.addEventListener('click', (e) => {
						const rect = this._target.getBoundingClientRect();
						const x = e.clientX - rect.left;
						const y = e.clientY - rect.top;
						this._userClick({ x: x, y: y });
					});
				};
				this._addPoint = (_x, _y) => {
					const rect = this._target.getBoundingClientRect();
					return {
						x: _x || rect.width * Math.random(),
						y: _y || rect.height * Math.random()
					};
				};
				this._drawLine = (start, end, lineWidth, strokeStyle) => {
					const ctx = this._target.getContext('2d');
					ctx.beginPath();
					ctx.lineWidth = lineWidth || 1;
					ctx.strokeStyle = strokeStyle || 'rgba(51, 102, 255, 1)';
					ctx.moveTo(start.x, start.y);
					ctx.lineTo(end.x, end.y);
					ctx.stroke();
				};
				this._drawDot = (dot, text, font, color) => {
					let ctx = this._target.getContext('2d');
					if (text !== undefined) {
						ctx.font = font || '13px Arial';
						ctx.fillStyle = '#333';
						ctx.fillText(text, dot.x, dot.y - 5);
					}
					ctx.beginPath();
					ctx.fillStyle = color || 'red';
					ctx.arc(dot.x, dot.y, 2, 0, 2 * Math.PI);
					ctx.fill();
				};
				this._fill = (color = '#111') => {
					let ctx = this._target.getContext('2d');
					const rect = this._target.getBoundingClientRect();
					ctx.rect(0, 0, rect.width, rect.height);
					ctx.fillStyle = color;
					ctx.fill();
				};
				this._blur = (radius = 3) => {
					let ctx = this._target.getContext('2d');
					ctx.filter = `blur(${radius}px)`;
					ctx.drawImage(this._target, 0, 0);
					ctx.filter = 'none';
				};
				this._drawChords = () => {
					for (var i = 0; i < this._data.length; i++) {
						if (i > 0) {
							this._drawLine(this._data[i - 1], this._data[i], .5, 'rgba(0,0,0,.5)');
						}
						this._drawDot(this._data[i], letters[i]);
					}
				};
				this._reDraw = () => {
					this._drawChords();
					if (this._data.length == this._dots) {
						this.animation = requestAnimationFrame(this._animate);
					}
				};
				this._userClick = (dot) => {
					cancelAnimationFrame(this.animation);
					if (this._userClickCouner == 0) {
						this._data = [];
						this._start = dot;
					}
					this._data.push(dot);
					this._clear();
					this._delta = 0;
					this._storage = [];
					this._reDraw();
					this._userClickCouner = (this._userClickCouner + 1) % this._dots;
				};
				this._calc = (start, end, t) => {
					return {
						x: start.x + (end.x - start.x) * t,
						y: start.y + (end.y - start.y) * t
					};
				};
				this._alg = (data, delta) => {
					if (data.length == 1) {
						return data[0];
					}
					let _result = [];
					for (var i = 0; i < data.length - 1; i++) {
						_result.push(this._calc(data[i], data[i + 1], delta));
					}
					let _alpha = (this._complex) ? .1 : 1;
					for (var i = 1; i < _result.length; i++) {
						this._drawLine(_result[i - 1], _result[i], .5, `rgba(${colors[_result.length % 5]}, ${_alpha})`);
					}
					if (!this._complex && _result.length > 1) {
						for (var j = 0; j < _result.length; j++) {
							this._drawDot(_result[j], '', undefined, `rgb(${colors[_result.length % 5]})`);
						}
					}
					return this._alg(_result, delta);
				};
				this._animate = () => {
					if (!this._complex) {
						this._clear();
						this._drawChords();
					}
					var result = this._alg(this._data, this._delta);
					this._storage.push(result);
					if (this._complex) {
						this._drawLine(this._start, result, 2);
						this._start = result;
					}
					else {
						for (var i = 0; i < this._storage.length - 1; i++) {
							this._drawLine(this._storage[i], this._storage[i + 1], 2);
						}
					}
					if (this._delta > 1) {
						cancelAnimationFrame(this.animation);
						if (!this._complex) {
							this._clear();
							this._drawChords();
						}
						for (var i = 0; i < this._storage.length - 1; i++) {
							this._drawLine(this._storage[i], this._storage[i + 1], 2);
						}
					}
					else {
						this._delta += (1 / (300 - this._speed * 2));
						this.animation = requestAnimationFrame(this._animate);
					}
				};
				this._demo_alg = (data, delta) => {
					let _result = [];
					for (var i = 0; i < data.length - 1; i++) {
						_result.push(this._calc(data[i], data[i + 1], delta));
					}
					if (_result.length > 1) {
						if (_result.length < this._data.length - 1) {
							for (var i = 1; i < _result.length; i++) {
								this._drawLine(_result[i - 1], _result[i], .5, `rgba(${colors[_result.length % 10]}, .2)`);
							}
						}
						this._demo_alg(_result, delta);
					}
				};
				this._demo_animate = () => {
					this._blur();
					this._demo_alg(this._data, this._delta);
					if (this._delta > .8) {
						cancelAnimationFrame(this.animation);
					}
					else {
						this._delta += 0.005;
						this.animation = requestAnimationFrame(this._demo_animate);
					}
				};
				this._demo_start = () => {
					this._clear();
					this._fill();
					this._delta = 0.2;
					this._dots = 5 + Math.floor(12 * Math.random());
					this._data = [];
					for (var i = 0; i < this._dots; i++) {
						var dot = this._addPoint();
						this._data.push(dot);
					}
					this.animation = requestAnimationFrame(this._demo_animate);
				};
				this.changeType = (type) => {
					switch (type) {
						case 3:
							this._dots = type;
							this._reset();
							break;
						case 4:
							this._dots = type;
							this._reset();
							break;
						default:
							break;
					}
				};
				this.redraw = () => {
					this._clear();
					this._delta = 0;
					this._storage = [];
					this._start = this._data[0];
					this._reDraw();
				};
				this.toggleSupport = () => {
					this._complex = !this._complex;
					this._clear();
					this._delta = 0;
					this._storage = [];
					this._start = this._data[0];
					this._reDraw();
				};
				this.changeDegree = (degree) => {
					this._dots = Math.max(2, degree);
					this._clear();
					this._delta = 0;
					this._storage = [];
					this._reset();
				};
				this.reset = () => {
					this._reset();
				};
				this.demo = () => {
					this._demo_start();
					clearInterval(this._demo_interval);
					this._demo_interval = setInterval(this._demo_start, 4500);
				};
				this.stop = () => {
					clearInterval(this._demo_interval);
				};
				this.clear = () => {
					cancelAnimationFrame(this.animation);
					this._clear();
				};
				this.setSpeed = (value) => {
					value = Math.max(Math.min(value, 100), 0);
					this._speed = value;
				};
				this._target = target;
				this.init();
			}
		}

		class Bspline {
			constructor(target) {
				this._type = 'simple';
				this._data = [];
				this._delta = 0;
				this._offset = 0;
				this._start = { x: 0, y: 0 };
				this._userClickCouner = 0;
				this._autoConstract = false;
				this._speed = 100;
				this._clear = () => {
					var _a;
					const rect = this._target.getBoundingClientRect();
					(_a = this._target.getContext('2d')) === null || _a === void 0 ? void 0 : _a.clearRect(0, 0, rect.width, rect.height);
					this._delta = 0;
					this._offset = 0;
				};
				this._reset = () => {
					this._clear();
					cancelAnimationFrame(this.animation);
					this._data = [];
					for (let i = 0; i < 4; i++) {
						let dot = this._addPoint();
						this._data.push(dot);
					}
					this._reDraw();
				};
				this.init = () => {
					this._reset();
					this._target.addEventListener('click', (e) => {
						const rect = this._target.getBoundingClientRect();
						const x = e.clientX - rect.left;
						const y = e.clientY - rect.top;
						this._userClick({ x: x, y: y });
					});
				};
				this._addPoint = (_x, _y) => {
					const rect = this._target.getBoundingClientRect();
					return {
						x: _x || rect.width * Math.random(),
						y: _y || rect.height * Math.random()
					};
				};
				this._drawLine = (start, end, lineWidth, strokeStyle) => {
					let ctx = this._target.getContext('2d');
					ctx.beginPath();
					ctx.lineWidth = lineWidth || 1;
					ctx.strokeStyle = strokeStyle || 'rgba(51, 102, 255, 1)';
					ctx.moveTo(start.x, start.y);
					ctx.lineTo(end.x, end.y);
					ctx.stroke();
				};
				this._drawSub = (dot, text) => {
					let ctx = this._target.getContext('2d');
					ctx.font = `9px Arial`;
					ctx.fillStyle = '#999';
					ctx.fillText(text, dot.x + 10, dot.y - 5);
				};
				this._drawDot = (dot, text, font) => {
					let ctx = this._target.getContext('2d');
					if (text !== undefined) {
						ctx.font = font || '13px Arial';
						ctx.fillStyle = '#333';
						ctx.textBaseline = 'bottom';
						ctx.fillText(text, dot.x, dot.y - 5);
					}
					if (this._type == 'complex') {
						this._drawSub(dot, String(Math.floor(this._data.length / 27)));
					}
					ctx.beginPath();
					ctx.fillStyle = 'red';
					ctx.arc(dot.x, dot.y, 2, 0, 2 * Math.PI);
					ctx.fill();
				};
				this._reDraw = () => {
					for (var i = 0; i < this._data.length; i++) {
						if (i > 0) {
							this._drawLine(this._data[i - 1], this._data[i], .5, 'rgba(0,0,0,.5)');
						}
						this._drawDot(this._data[i], letters[i]);
					}
					if (this._data.length == 4) {
						this._start = this._calc(this._data[0], this._data[1], this._data[2], this._data[3], 0);
						this.animation = requestAnimationFrame(this._animate);
					}
				};
				this._userClick = (dot) => {
					switch (this._type) {
						case 'simple':
							cancelAnimationFrame(this.animation);
							if (this._userClickCouner == 0) {
								this._data = [];
							}
							this._data.push(dot);
							this._clear();
							this._reDraw();
							this._userClickCouner = (this._userClickCouner + 1) % 4;
							break;
						case 'complex':
							this._data.push(dot);
							let length = this._data.length - 1;
							this._drawLine(this._data[length - 1], this._data[length], .5, 'rgba(0,0,0,.5)');
							this._drawDot(this._data[length], letters[length % 26]);
							if (!this.animation) {
								this.animation = requestAnimationFrame(this._animate);
							}
							break;
						default:
							break;
					}
				};
				this._calc = (p1, p2, p3, p4, t) => {
					let m1 = Math.pow((1 - t), 3) / 6;
					let m2 = (3 * Math.pow(t, 3) - 6 * Math.pow(t, 2) + 4) / 6;
					let m3 = (-3 * Math.pow(t, 3) + 3 * Math.pow(t, 2) + 3 * t + 1) / 6;
					let m4 = Math.pow(t, 3) / 6;
					return {
						x: m1 * p1.x + m2 * p2.x + m3 * p3.x + m4 * p4.x,
						y: m1 * p1.y + m2 * p2.y + m3 * p3.y + m4 * p4.y
					};
				};
				this._animate = () => {
					var result = this._calc(this._data[this._offset], this._data[this._offset + 1], this._data[this._offset + 2], this._data[this._offset + 3], this._delta);
					this._drawLine(this._start, result, 2);
					this._start = result;
					if (this._delta > 1) {
						switch (this._type) {
							case 'simple':
								cancelAnimationFrame(this.animation);
								break;
							case 'complex':
								if (this._offset == this._data.length - 4 && this._autoConstract) {
									let dot = this._addPoint();
									this._data.push(dot);
									let length = this._data.length - 1;
									this._drawLine(this._data[length - 1], this._data[length], .5, 'rgba(0,0,0,.5)');
									this._drawDot(this._data[length], letters[length % 26]);
								}
								if (this._offset < this._data.length - 4) {
									this._offset++;
									this._delta = 0;
									this.animation = requestAnimationFrame(this._animate);
								}
								else {
									cancelAnimationFrame(this.animation);
									this._offset++;
									this._delta = 0;
									this.animation = null;
								}
								break;
							default:
								break;
						}
					}
					else {
						this._delta += 1 / (200 - this._speed);
						this.animation = requestAnimationFrame(this._animate);
					}
				};
				this.changeType = (type) => {
					switch (type) {
						case 'simple':
							this._type = type;
							this._userClickCouner = 0;
							this._reset();
							break;
						case 'complex':
							this._type = type;
							this.redraw();
							break;
						default:
							break;
					}
				};
				this.redraw = () => {
					this._clear();
					this._start = this._calc(this._data[0], this._data[1], this._data[2], this._data[3], 0);
					this._reDraw();
				};
				this.toggleSupport = () => {
					this._autoConstract = !this._autoConstract;
				};
				this.reset = () => {
					this._reset();
				};
				this.clear = () => {
					cancelAnimationFrame(this.animation);
					this._clear();
				};
				this.setSpeed = (value) => {
					value = Math.max(Math.min(value, 100), 0);
					this._speed = value;
				};
				this._target = target;
				this.init();
			}
		}

		var init = () => {
			var _a, _b, _c, _d, _e, _f, _g, _h, _j;
			const canvas_bezie = document.getElementById('bezie');
			const canvas_bezie_demo = document.getElementById('bezie_demo');
			const canvas_bspline = document.getElementById('bspline');
			const bezie = new Bezie(canvas_bezie);
			const bezie_demo = new Bezie(canvas_bezie_demo);
			const bspline = new Bspline(canvas_bspline);
			const parent = document.querySelector('body > section');
			let _width;
			function resizeCanvas() {
				if ((parent === null || parent === void 0 ? void 0 : parent.clientWidth) != _width) {
					_width = parent === null || parent === void 0 ? void 0 : parent.clientWidth;
					if (canvas_bezie !== null)
						canvas_bezie.width = (_width || 1000) - 2;
					if (canvas_bspline !== null)
						canvas_bspline.width = (_width || 1000) - 2;
					if (canvas_bezie_demo !== null) {
						canvas_bezie_demo.width = window.innerWidth;
						canvas_bezie_demo.height = window.innerHeight;
					}
					bezie.redraw();
					bspline.reset();
				}
			}
			bezie.reset();
			bspline.reset();
			bezie_demo.toggleSupport();
			resizeCanvas();
			window.addEventListener('resize', resizeCanvas);
			(_a = document.querySelector('input[name="bezie_degree"]')) === null || _a === void 0 ? void 0 : _a.addEventListener('input', function (e) {
				const input = e.target;
				const value = input.value.replace(/\D/g, '');
				const numb = Math.min(17, parseInt(value));
				input.value = numb.toString();
				bezie.changeDegree(parseInt(input === null || input === void 0 ? void 0 : input.value) + 1);
			});
			(_b = document.querySelector('#bezie_redraw_btn')) === null || _b === void 0 ? void 0 : _b.addEventListener('click', function (e) {
				bezie.redraw();
			});
			(_c = document.querySelector('#bezie_reset_btn')) === null || _c === void 0 ? void 0 : _c.addEventListener('click', function (e) {
				bezie.reset();
			});
			// document.querySelector('#bezie_support_btn')?.addEventListener('click', function(e) {
			// 	bezie.toggleSupport();
			// });
			(_d = document.querySelector('#bezie_demo_btn')) === null || _d === void 0 ? void 0 : _d.addEventListener('click', function (e) {
				var _a;
				(_a = document.querySelector('.demo')) === null || _a === void 0 ? void 0 : _a.classList.add('visible');
				bezie_demo.demo();
			});
			(_e = document.querySelector('#bezie_speed')) === null || _e === void 0 ? void 0 : _e.addEventListener('input', function (e) {
				const input = e.target;
				bezie.setSpeed(parseInt(input === null || input === void 0 ? void 0 : input.value));
			});
			// document.querySelector('#bezie_clear')?.addEventListener('click', function(e) {
			// 	bezie.clear();
			// });
			(_f = document.querySelector('.demo')) === null || _f === void 0 ? void 0 : _f.addEventListener('click', function (e) {
				var _a;
				(_a = document.querySelector('.demo')) === null || _a === void 0 ? void 0 : _a.classList.remove('visible');
				bezie_demo.stop();
			});
			document.querySelectorAll('input[name="bspline_type"]').forEach(radio => {
				radio.addEventListener('change', function (e) {
					let value = e.target.value;
					bspline.changeType(value);
				});
			});
			(_g = document.querySelector('#bspline_reset_btn')) === null || _g === void 0 ? void 0 : _g.addEventListener('click', function (e) {
				bspline.reset();
			});
			(_h = document.querySelector('#bspline_auto_btn')) === null || _h === void 0 ? void 0 : _h.addEventListener('click', function (e) {
				bspline.toggleSupport();
			});
			(_j = document.querySelector('#bspline_speed')) === null || _j === void 0 ? void 0 : _j.addEventListener('input', function (e) {
				const input = e.target;
				bspline.setSpeed(parseInt(input === null || input === void 0 ? void 0 : input.value));
			});
			// document.querySelector('#bspline_clear')?.addEventListener('click', function(e) {
			// 	bspline.clear();
			// });
		};
		//document.addEventListener('DOMContentLoaded', init);
		window.addEventListener('load', init);
	</script>
</body>
</html>